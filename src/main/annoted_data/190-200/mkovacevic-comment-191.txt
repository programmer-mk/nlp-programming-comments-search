/// <summary>
/// Metoda kojom se pokrece rasporedjivanje
/// </summary>

public void work()
{

    while (listOfTasks.Count != 0)
    {
        TaskToDo task = listOfTasks[0];
        listOfTasks.RemoveAt(0);
        if (task.listOfDelegates.Count != 0)
        {

            ObjectSatus taskStatus = mapOfTaskStatus[task];
            if ((isResursFree(task.resurs) || task.ILockedResurs)  && !taskStatus.inUse)
            {

                ObjectSatus resursStatus = mapOfResursStatus.ContainsKey(task.resurs) ? mapOfResursStatus[task.resurs] : null;

                if ((threadPool.Count < numOfThreads) && isAllThreadsWork())
                {

                    MyThreadForPreemptiveScheduler thread = new MyThreadForPreemptiveScheduler();
                    doContextSwitching(thread,resursStatus,taskStatus,task);

                    listOfTasks.Add(task);
                    threadPool.Add(thread);
                    new Thread(thread.run).Start();
                    Thread.Sleep(50);
                }
                else
                {

                    MyThreadForPreemptiveScheduler thread = getFreeThread();
                    doContextSwitching(thread, resursStatus, taskStatus,task);

                    listOfTasks.Add(task);
                    thread.restartThread();
                    Thread.Sleep(50);

                }

            }
            else
            {
                listOfTasks.Add(task);
            }
        }



    }
    while (threadPool.Count != 0) {
        foreach(MyThreadForPreemptiveScheduler thread in threadPool)
        {
            if (thread.inRun == false)
            {
                thread.terminateThread();
                thread.restartThread();
                threadPool.Remove(thread);
                break;
            }
        }
    }
    Console.WriteLine("Svi tredovi terminirani");


}

https://github.com/DjordjeCvijic/OposZadaci2020/blob/b2b9eda3f715be8b7ceea9dd0ecc6113c40b2f2e/Zadatak%201-Rasporedjivac/ClassLibrary1/SchedulersAPI.cs